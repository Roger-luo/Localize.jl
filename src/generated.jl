"""
    path(multidoc, binding, sig) -> String
Returns the path of this binding with given signature.
"""
path(m::MultiDoc, b::Binding, sig) = m.docs[sig].data[:module] => m.docs[sig].data[:path]

"""
    paths(multidoc, binding) -> Generator
Returns an iterator of path of the documents of this binding.
"""
paths(m::MultiDoc, b::Binding) = (path(m, b, sig) for sig in m.order)

"""
    paths(module) -> Set
Returns an `Set` object that contains the unique relative path of doc strings.
"""
function paths(__module__::Module)
    META = Docs.meta(__module__)
    PATH = Set()
    for (b, m) in META
        for each in paths(m, b)
            push!(PATH, each)
        end
    end
    PATH
end


"""
    dump_str(binding[, sig]) -> String
dump a `binding` and a signature `sig` to raw script.
"""
function dump_str end

dump_str(b::Binding) = "$(b.var)"

function dump_str(b::Binding, sig)
    if sig === Union{}
        "$(b.var)"
    else
        "$(b.var) $sig"
    end
end

function dump_str(b::Binding, sig::Type{<:Tuple})
    o = "$(b.var)"

    args = join(["::$each" for each in sig.types], ", ")
    !isempty(args) && return o * "(" * args * ")"
    o
end

function allpaths(__module__::Module)
    PATH = paths(__module__)
    for each in submodules(__module__)
        union!(PATH, allpaths(each))
    end
    PATH
end

template(mod::Module; content="# translation goes here") =
###### Template
"""
@i18n $mod begin
$content
end
"""

################################################################################

readme() = """
# I18n generated files
Files and dirs in this folder is generated by [Localize.jl](). This keeps the original directory structure and adds
i18n macros to each file. Just simply put your translation in each generated Julia script.
"""


include_string(path::String) = "include(\"$path\")"

function generate(__module__::Module, root; workdir=pwd())
    if ispath(root)
        @warn "overwriting existing path: $root"
    else
        mkpath(root)
    end

    open(joinpath(root, "README.md"), "w+") do f
        write(f, readme())
    end

    include_paths = String[]
    files = Dict{String, Vector{Module}}()

    # merge different module paths
    for (mod, each) in allpaths(__module__)
        if haskey(files, each)
            push!(files[each], mod)
        else
            files[each] = [mod]
        end
    end

    for (each, mods) in files
        path = joinpath(root, each)
        push!(include_paths, each)
        mkpath(dirname(path))

        printstyled("path: "; bold=true, color=:light_black)
        println(path)

        open(path, "a+") do f
            printstyled("module: "; bold=true, color=:light_blue)
            for mod in mods
                printstyled(mod; bold=true, color=:yellow)
                print(" ") # make a new line

                write(f, template(mod))
            end
        end
        println("\n")
    end

    include_script = join(include_string.(include_paths), "\n")

    open(joinpath(root, "__main__.jl"), "w+") do f
        write(f, include_script)
        write(f, "\n") # add line break at the EOF
    end
    nothing
end

generate(root) = generate(Base, root)
